#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <ctime>
#include <limits>
#include <cmath>
#include <vector>
//#include <chrono>
//#include <random>
#define POPULATION_SIZE 10
#define MAX_ITERATION 1
#define TOURNAMENT_SIZE 2
#define CPX_PROB 0.3
#define MUT_PROB 0.5
using namespace std;

double best_chr = std::numeric_limits<double>::max() ;
char *fname;
int chromosome_length;
double *x;
double *y;
double *best_one,optimal;
int *selectedParents,optimum;
int *p;
double *fitness_array;
int display_optimum;
double *display_fitness;
int temp_deger = 0;
int **crh_matris;
int **mating_pool;
int **display_pool;
double *dist;
int *visited_vertex;
double nnh_result=0;
double total_dist = 0;
ifstream tspfile_file;
void fetch();
void generate_population();
void selection();
void crossover();
void mutation();
double fitness(int*);
void total_fitness();
void copy_crh2mating();
void print();
double NNH();

//default_random_engine generator;
//uniform_real_distribution<double> picker;


int main(int argc,char *argv[])
{
    fname=argv[1];
    //srand(time(0));
    fetch();
    // construct a trivial random generator engine from a time-based seed:
    //unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    //std::default_random_engine generator (seed);
    //std::uniform_real_distribution<> distribution (1,chromosome_length);

    nnh_result=NNH();
    generate_population();
    for (int i = 0; i<MAX_ITERATION; i++)
    {
        selection();
        crossover();
        mutation();
        total_fitness();
    }
    print();


}
void fetch()
{

	tspfile_file.open(fname);
	tspfile_file >> chromosome_length;

	x = new double[chromosome_length];
	y = new double[chromosome_length];
	best_one = new double[chromosome_length];
    dist=new double[chromosome_length];
    visited_vertex=new int[chromosome_length];
	fitness_array = new double[POPULATION_SIZE];

	selectedParents = new int[POPULATION_SIZE];
	crh_matris = new int*[POPULATION_SIZE];
	mating_pool = new int*[POPULATION_SIZE];


	display_fitness = new double[POPULATION_SIZE];
    display_pool=new int*[POPULATION_SIZE];

	for (int i = 0; i<POPULATION_SIZE; i++)
	{
		crh_matris[i] = new int[chromosome_length];
		mating_pool[i] = new int[chromosome_length];
		display_pool[i] = new int[chromosome_length];
	}
	for (int i = 0; i < chromosome_length; i++)
	{
		tspfile_file >> x[i];
		tspfile_file >> y[i];
	}
}
void generate_population()
{
	int i, j;int temp,mut1,mut2,mem1,mem2;
	p = new int[chromosome_length];
	for(i=0;i<chromosome_length;i++)
        mating_pool[0][i]=visited_vertex[i];
    fitness_array[0]=nnh_result;
    for(i=0;i<POPULATION_SIZE-1;i++)
    {

        ////// mating pool is filled by mutation of nearest neighbour  solution.
        mut1=rand()%chromosome_length;
        mut2=rand()%chromosome_length;

        mem1=visited_vertex[mut1];
        mem2=visited_vertex[mut2];

       /////swapp
        temp=visited_vertex[mut1];
        visited_vertex[mut1]=visited_vertex[mut2];
        visited_vertex[mut2]=temp;

        for(j=0;j<chromosome_length;j++)
            mating_pool[i+1][j]=visited_vertex[j];

        visited_vertex[mut1]=mem1;
        visited_vertex[mut2]=mem2;
        fitness_array[i+1]=fitness(mating_pool[i+1]);

    }

	/*for (int pop = POPULATION_SIZE/2; pop<POPULATION_SIZE; pop++)
	{
		for (int ii = 0; ii<chromosome_length; ii++)
			p[ii] = ii;
		for (i = chromosome_length - 1; i>0; --i)
		{
			j = rand() % (i + 1);//5

			temp = p[i];
			p[i] = p[j];
			p[j] = temp;
		}
		for (int ii = 0; ii<chromosome_length; ii++)
		{
			//crh_matris[pop][ii] = p[ii];
			mating_pool[pop][ii] = p[ii];
		}

		fitness_array[pop] = fitness(mating_pool[pop]);
	}*/
}
void selection()
{

    int i, j, optimal, temp;
	for (i = 0; i<POPULATION_SIZE; i++)
	{
		optimal = rand() % POPULATION_SIZE;
		for (j = 0; j<TOURNAMENT_SIZE; j++)
		{
			temp = rand() % POPULATION_SIZE;
			if (fitness_array[temp]<fitness_array[optimal])
				optimal = temp;
		}
		selectedParents[i] = optimal;
	}

    for (i = 0; i<POPULATION_SIZE; i++)
    {
        for (j = 0; j<chromosome_length; j++)
            mating_pool[i][j] = mating_pool[selectedParents[i]][j];
        fitness_array[i] = fitness(mating_pool[i]);
    }
	///// compare  with NNH resultbourhood -in aldigi result daha iyiyse,onu al.
	////nearest neighbourhood implementation
	////Nearest Neighbourhood algorithm implementation

	/*for (i = 0; i<POPULATION_SIZE; i++)
	{
		optimal = rand() % POPULATION_SIZE;
			if (fitness_array[optimal]<nnh_result)
		selectedParents[i] = visited_vertex[i];
	}
    */

    /////Stochastic Universal Sampling (SUS)
    /*int i, j, optimal,temp;
    double delta,MEAN,SUM=0;

	for(i =0; i<POPULATION_SIZE; i++)
      SUM = SUM + fitness_array[i];      ////calculate sum of all fitness of all indivduals in mating pool

    MEAN = SUM / POPULATION_SIZE;
    double alfa = ((double)rand()/(double)(RAND_MAX));     //// generate a random number in [0,1]

    SUM = fitness_array[0];
    delta = alfa*MEAN;

	//for (i = 0; i<POPULATION_SIZE; i++)
	//{
		//optimal = rand() % POPULATION_SIZE;
		j=0;
		do                                        //TOURNAMENT_SIZE; j++)
		{
		     if(delta<SUM)
            {
                //temp = rand() % POPULATION_SIZE;
                //if (fitness_array[temp]<fitness_array[optimal])
                //optimal = temp;
                optimal=j;
                delta=delta+SUM;
                selectedParents[j] = optimal;
            }
            else
            {
               //j=j+1;
               do
                {
                    SUM=SUM+fitness_array[j];
                }while(delta>=SUM);

                selectedParents[j] = optimal;
            }
              j++;
         }while(j<POPULATION_SIZE);

     for (i = 0; i<POPULATION_SIZE; i++)
	 {
        for (j = 0; j<chromosome_length; j++)
            mating_pool[i][j] = mating_pool[selectedParents[i]][j];
         fitness_array[i] = fitness(mating_pool[i]);
     }*/


}
void crossover()
{
	int temp_deger = 0;
	int i, j;
	int index;

	int counter1 = 0;
	int counter2 = 0;

	int cut1 = chromosome_length / 3;
	int cut2 = chromosome_length * 2 / 3;

	for (int pop = 0; pop<POPULATION_SIZE - 1; pop = pop + 2)
	{
	    std::vector<int> rv1;
	    std::vector<int> rv2;

        //double p = picker(generator);
		double p = (double)rand() / RAND_MAX;
		if (p<CPX_PROB)
		{
			for (int cutting = cut1; cutting<cut2; cutting++)
			{
				temp_deger = mating_pool[pop][cutting];
				mating_pool[pop][cutting] = mating_pool[pop + 1][cutting];
				mating_pool[pop + 1][cutting] = temp_deger;
			}

			//************************
			index = 0;
			do
			{
				for (i = cut1; i<cut2; i++)
				{
					if (mating_pool[pop][index] == mating_pool[pop][i])
					{
						rv1.push_back(mating_pool[pop][index]);
					}
				}
				index++;
				if (index == cut1)
					index = cut2;
			} while (index<chromosome_length);

			index = 0;
			do
			{
				for (i = cut1; i<cut2; i++)
				{
					if (mating_pool[pop + 1][index] == mating_pool[pop + 1][i])
					{
						rv2.push_back(mating_pool[pop + 1][index]);
					}
				}
				index++;
				if (index == cut1)
					index = cut2;
			} while (index<chromosome_length);

			//*************************
			index = 0;
			for (int i = 0; i<rv1.size(); i++)
			{
				index = 0;
				do
				{
					if (mating_pool[pop][index] == rv1[i])
						mating_pool[pop][index] = rv2[i];
					index++;
					if (index == cut1)
						index = cut2;
				} while (index < chromosome_length);
			}      //// end for the first array
			//print();
			index = 0;
			for (int i = 0; i<rv2.size(); i++)
			{
				index = 0;
				do
				{
					if (mating_pool[pop + 1][index] == rv2[i])
						mating_pool[pop + 1][index] = rv1[i];
					index++;
					if (index == cut1)
						index = cut2;
				} while (index < chromosome_length);
			}  ////end for the second array
		}
	}

}
void mutation()
{
	double p;
	int i;
	int city1, city2, temp;
	for (i = 0; i<POPULATION_SIZE; i++)
	{
        //double p = picker(generator);

		p = (double)rand() / RAND_MAX;
		if (p<MUT_PROB)
		{
			city1 = rand() % chromosome_length;
			city2 = rand() % chromosome_length;

			temp = mating_pool[i][city1];
			mating_pool[i][city1] = mating_pool[i][city2];
			mating_pool[i][city2] = temp;
		}
	}
}
void total_fitness()
{
	int temp_val1;
	int temp_val2;
	double calc_fitness;
	int optimum;

	for (int i = 0; i<POPULATION_SIZE; i++)
	{
		calc_fitness = 0;
		for (int j = 0; j < chromosome_length - 1; j++)
		{
			temp_val1 = mating_pool[i][j];
			temp_val2 = mating_pool[i][j + 1];
			calc_fitness = calc_fitness + sqrt(((x[temp_val1] - x[temp_val2])*(x[temp_val1] - x[temp_val2])) + ((y[temp_val1] - y[temp_val2])*(y[temp_val1] - y[temp_val2])));
		}

		temp_val1 = mating_pool[i][0];
        temp_val2 = mating_pool[i][chromosome_length - 1];
        calc_fitness = calc_fitness + sqrt(((x[temp_val1] - x[temp_val2])*(x[temp_val1] - x[temp_val2])) + ((y[temp_val1] - y[temp_val2])*(y[temp_val1] - y[temp_val2])));

		fitness_array[i] = calc_fitness;
		//cout << endl << "Fitness result is "<< calc_fitness;
	}
	optimum = 0;
	for (int i = 1; i<POPULATION_SIZE; i++)
	{
		if (fitness_array[i]<fitness_array[optimum])
			optimum = i;
	}
	if (fitness_array[optimum]<best_chr)
	{
		best_chr = fitness_array[optimum];
		for (int i = 0; i<chromosome_length; i++)
			best_one[i] = mating_pool[optimum][i];

        display_optimum=optimum;

		display_fitness[optimum]=fitness_array[optimum];
		for (int i = 0; i<chromosome_length; i++)
			display_pool[optimum][i] = mating_pool[optimum][i];

	}
}
double fitness(int *arr)
{
	int temp_val1;
	int temp_val2;
	double calc_fitness;
	calc_fitness = 0;
	for (int j = 0; j < chromosome_length - 1; j++)
	{
		temp_val1 = arr[j];
		temp_val2 = arr[j + 1];
		calc_fitness = calc_fitness + sqrt(((x[temp_val1] - x[temp_val2])*(x[temp_val1] - x[temp_val2])) + ((y[temp_val1] - y[temp_val2])*(y[temp_val1] - y[temp_val2])));
	}

	return calc_fitness;
}
void copy_crh2mating()
{
	int i, j;
	for (i = 0; i<POPULATION_SIZE; i++)
	{
		for (j = 0; j<chromosome_length; j++)
			mating_pool[i][j] = crh_matris[i][j];
	}
}
void print()
{
	cout << best_chr<< endl;
    for (int i = 0; i<chromosome_length; i++)
        cout<<display_pool[display_optimum][i]<<" ";
    cout << endl;
}

double NNH()
{

   int r;
   r = rand() % chromosome_length;

   visited_vertex[0]=r;
   int min_index;
   double min;

   for(int j=1; j<chromosome_length; j++)
   {
        min =numeric_limits<double>::max();

       for(int i=0; i<chromosome_length;i++)
       {

        dist[i]=sqrt(((x[visited_vertex[j-1]] - x[i])*(x[visited_vertex[j-1]] - x[i])) + ((y[visited_vertex[j-1]] - y[i])*(y[visited_vertex[j-1]] - y[i])));

           for (int k=0; k<j; k++)
           {
                if(i==visited_vertex[k])
                    dist[i]=numeric_limits<double>::max();
            }
            if(dist[i]<min)
            {
                min = dist[i];
                min_index=i;
            }
       }

       visited_vertex[j]=min_index;
       total_dist=total_dist+min;
   }

    double a = sqrt(((x[visited_vertex[0]] - x[chromosome_length-1])*(x[visited_vertex[0]] - x[chromosome_length-1])) + ((y[visited_vertex[0]] - y[chromosome_length-1])*(y[visited_vertex[0]] - y[chromosome_length-1])));
    total_dist=total_dist +a;

    return total_dist;

}
